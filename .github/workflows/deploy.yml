name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger from GitHub UI

env:
  NODE_VERSION: '22'
  NODE_ENV: 'production'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    name: Build & Test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint --if-present
        continue-on-error: true  # Don't fail deployment if lint fails

      - name: Run tests
        run: npm test
        continue-on-error: true  # Tests are informational

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    name: Deploy to EC2 via EC2 Instance Connect
    if: success()
    
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::637423355461:role/github-actions-ec2-deploy-oidc
          aws-region: us-east-1

      - name: Deploy via EC2 Instance Connect
        env:
          INSTANCE_ID: i-086b6a2ef671e8c63
          OS_USER: ec2-user
          EC2_HOST: ${{ secrets.EC2_DEPLOY_HOST }}
        run: |
          # Generate temporary SSH key pair
          ssh-keygen -t rsa -N "" -f /tmp/ec2-deploy-key
          
          # Push public key to EC2 (valid 60 seconds)
          aws ec2-instance-connect send-ssh-public-key \
            --instance-id $INSTANCE_ID \
            --instance-os-user $OS_USER \
            --ssh-public-key file:///tmp/ec2-deploy-key.pub \
            --region us-east-1
          
          # SSH using temporary key
          ssh -i /tmp/ec2-deploy-key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            ${OS_USER}@${EC2_HOST} << 'DEPLOY_SCRIPT'
          set -e
          
          echo "Starting deployment..."
          cd /opt/enscribe-api
          
          # Pull latest code
          echo "Pulling latest code from main branch..."
          git fetch origin main
          git reset --hard origin/main
          
          # Install dependencies
          echo "Installing dependencies..."
          npm ci --omit=dev
          
          # Create .env.local with secrets from GitHub
          echo "Setting up environment variables..."
          cat > .env.local << 'ENVEOF'
          # Supabase Configuration
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          
          # Fastify Server Configuration
          FASTIFY_HOST=0.0.0.0
          FASTIFY_PORT=${{ secrets.FASTIFY_PORT }}
          NODE_ENV=production
          ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
          
          # OpenAI Configuration
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENAI_API_URL=${{ secrets.OPENAI_API_URL }}
          
          # Google Cloud Configuration
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_SERVICE_ACCOUNT_KEY=${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_URL=${{ secrets.GEMINI_API_URL }}
          GCP_ZONE=${{ secrets.GCP_ZONE }}
          GCP_VM_INSTANCE_NAME=${{ secrets.GCP_VM_INSTANCE_NAME }}
          GCP_VM_RATE_LIMIT_MAX_CALLS=${{ secrets.GCP_VM_RATE_LIMIT_MAX_CALLS }}
          GCP_VM_RATE_LIMIT_WINDOW_SEC=${{ secrets.GCP_VM_RATE_LIMIT_WINDOW_SEC }}
          CLOUD_RUN_TRANSCRIBE_URL=${{ secrets.CLOUD_RUN_TRANSCRIBE_URL }}
          
          # AWS Region (IAM role handles AWS service access, no explicit credentials needed)
          AWS_REGION=${{ secrets.AWS_REGION }}
          
          # Authentication & Security
          RSA_PRIVATE_KEY=${{ secrets.RSA_PRIVATE_KEY }}
          RSA_PUBLIC_KEY=${{ secrets.RSA_PUBLIC_KEY }}
          REFRESH_TOKEN_AES_KEY_HEX=${{ secrets.REFRESH_TOKEN_AES_KEY_HEX }}
          REFRESH_TOKEN_SIGNING_KEY_HEX=${{ secrets.REFRESH_TOKEN_SIGNING_KEY_HEX }}
          
          # Refresh Token Configuration
          REFRESH_COOKIE_DOMAIN=${{ secrets.REFRESH_COOKIE_DOMAIN }}
          REFRESH_COOKIE_SAMESITE=${{ secrets.REFRESH_COOKIE_SAMESITE }}
          REFRESH_COOKIE_SECURE=${{ secrets.REFRESH_COOKIE_SECURE }}
          REFRESH_INACTIVITY_LIMIT_SECONDS=${{ secrets.REFRESH_INACTIVITY_LIMIT_SECONDS }}
          REFRESH_MAX_AGE_SECONDS=${{ secrets.REFRESH_MAX_AGE_SECONDS }}
          
          # CPU Threshold for GCP VM
          CPU_THRESHOLD=${{ secrets.CPU_THRESHOLD }}
          ENVEOF
          
          # Restart PM2 services
          echo "Restarting Fastify backend..."
          pm2 restart fastify-server || pm2 start "npm run start:fastify" --name "fastify-server" --env production
          
          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 5
          
          # Health check
          echo "Verifying backend health..."
          FASTIFY_PORT=${{ secrets.FASTIFY_PORT }}
          for i in {1..10}; do
            if curl -f http://localhost:${FASTIFY_PORT}/health > /dev/null 2>&1; then
              echo "âœ“ Fastify backend is healthy on port ${FASTIFY_PORT}"
              break
            fi
            echo "Attempt $i/10 - Waiting for backend..."
            sleep 2
          done
          
          # Save PM2 config
          pm2 save
          
          echo "Deployment completed successfully!"
          pm2 status
          DEPLOY_SCRIPT
