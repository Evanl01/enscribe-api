name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger from GitHub UI

env:
  NODE_VERSION: '22'
  NODE_ENV: 'production'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    name: Build & Test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint --if-present
        continue-on-error: true  # Don't fail deployment if lint fails

      - name: Run tests
        run: npm test
        continue-on-error: true  # Tests are informational

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    name: Deploy to EC2 via Systems Manager
    if: success()
    
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::637423355461:role/enscribe-api-ec2-instance-role
          aws-region: us-east-1

      - name: Deploy via Systems Manager
        env:
          INSTANCE_ID: i-086b6a2ef671e8c63
        run: |
          # Create deployment script with all secrets
          cat > /tmp/deploy.sh << 'DEPLOYEOF'
          set -e
          DEPLOY_START=$(date +%s)
          echo "Starting deployment at $(date)"
          cd /opt/enscribe-api
          
          PULL_START=$(date +%s)
          echo "Pulling latest code from main branch..."
          
          # Fix git ownership (SSM runs as ssm-user, directory already owned by ssm-user)
          git config --global --add safe.directory /opt/enscribe-api
          
          # Add timeout to git operations (30 seconds max)
          timeout 30 git fetch origin main || { echo "Git fetch timed out or failed"; exit 1; }
          timeout 30 git reset --hard origin/main || { echo "Git reset timed out or failed"; exit 1; }
          PULL_END=$(date +%s)
          echo "✓ Git pull completed in $((PULL_END - PULL_START))s"
          
          INSTALL_START=$(date +%s)
          echo "Installing dependencies..."
          npm ci --omit=dev
          INSTALL_END=$(date +%s)
          echo "✓ npm install completed in $((INSTALL_END - INSTALL_START))s"
          
          ENV_START=$(date +%s)
          echo "Setting up environment variables..."
          cat > .env.local << 'ENVEOF'
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          FASTIFY_HOST=0.0.0.0
          FASTIFY_PORT=${{ secrets.FASTIFY_PORT }}
          NODE_ENV=production
          ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENAI_API_URL=${{ secrets.OPENAI_API_URL }}
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_SERVICE_ACCOUNT_KEY=${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_URL=${{ secrets.GEMINI_API_URL }}
          GCP_ZONE=${{ secrets.GCP_ZONE }}
          GCP_VM_INSTANCE_NAME=${{ secrets.GCP_VM_INSTANCE_NAME }}
          GCP_VM_RATE_LIMIT_MAX_CALLS=${{ secrets.GCP_VM_RATE_LIMIT_MAX_CALLS }}
          GCP_VM_RATE_LIMIT_WINDOW_SEC=${{ secrets.GCP_VM_RATE_LIMIT_WINDOW_SEC }}
          CLOUD_RUN_TRANSCRIBE_URL=${{ secrets.CLOUD_RUN_TRANSCRIBE_URL }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          RSA_PRIVATE_KEY=${{ secrets.RSA_PRIVATE_KEY }}
          RSA_PUBLIC_KEY=${{ secrets.RSA_PUBLIC_KEY }}
          REFRESH_TOKEN_AES_KEY_HEX=${{ secrets.REFRESH_TOKEN_AES_KEY_HEX }}
          REFRESH_TOKEN_SIGNING_KEY_HEX=${{ secrets.REFRESH_TOKEN_SIGNING_KEY_HEX }}
          REFRESH_COOKIE_DOMAIN=${{ secrets.REFRESH_COOKIE_DOMAIN }}
          REFRESH_COOKIE_SAMESITE=${{ secrets.REFRESH_COOKIE_SAMESITE }}
          REFRESH_COOKIE_SECURE=${{ secrets.REFRESH_COOKIE_SECURE }}
          REFRESH_INACTIVITY_LIMIT_SECONDS=${{ secrets.REFRESH_INACTIVITY_LIMIT_SECONDS }}
          REFRESH_MAX_AGE_SECONDS=${{ secrets.REFRESH_MAX_AGE_SECONDS }}
          CPU_THRESHOLD=${{ secrets.CPU_THRESHOLD }}
          ENVEOF
          ENV_END=$(date +%s)
          echo "✓ Environment variables set in $((ENV_END - ENV_START))s"
          
          RESTART_START=$(date +%s)
          echo "Restarting Fastify backend..."
          # Kill any processes stuck on port 3001
          lsof -ti:3001 | xargs kill -9 2>/dev/null || true
          sleep 2
          pm2 restart fastify-server || pm2 start "npm run start:fastify" --name "fastify-server" --env production
          RESTART_END=$(date +%s)
          echo "✓ PM2 restart completed in $((RESTART_END - RESTART_START))s"
          
          HEALTH_START=$(date +%s)
          echo "Waiting for services to start..."
          sleep 5
          
          echo "Verifying backend health..."
          HEALTH_TIMEOUT=30  # 30 second timeout for health check
          HEALTH_CHECK_START=$(date +%s)
          
          while [ $(($(date +%s) - HEALTH_CHECK_START)) -lt $HEALTH_TIMEOUT ]; do
            if curl -f -m 5 http://localhost:${{ secrets.FASTIFY_PORT }}/health > /dev/null 2>&1; then
              echo "✓ Fastify backend is healthy on port ${{ secrets.FASTIFY_PORT }}"
              break
            fi
            echo "Waiting for backend to respond..."
            sleep 2
          done
          HEALTH_END=$(date +%s)
          echo "✓ Health check completed in $((HEALTH_END - HEALTH_START))s"
          
          DEPLOY_END=$(date +%s)
          TOTAL_TIME=$((DEPLOY_END - DEPLOY_START))
          
          echo "---DEPLOYMENT TIMING SUMMARY---"
          echo "Git pull: $((PULL_END - PULL_START))s"
          echo "npm install: $((INSTALL_END - INSTALL_START))s"
          echo "Environment setup: $((ENV_END - ENV_START))s"
          echo "PM2 restart: $((RESTART_END - RESTART_START))s"
          echo "Health check: $((HEALTH_END - HEALTH_START))s"
          echo "TOTAL DEPLOYMENT TIME: ${TOTAL_TIME}s ($((TOTAL_TIME / 60))m $((TOTAL_TIME % 60))s)"
          echo "---END TIMING SUMMARY---"
          
          # Write timing to file for retrieval even if GitHub Actions times out
          {
            echo "---DEPLOYMENT TIMING SUMMARY---"
            echo "Git pull: $((PULL_END - PULL_START))s"
            echo "npm install: $((INSTALL_END - INSTALL_START))s"
            echo "Environment setup: $((ENV_END - ENV_START))s"
            echo "PM2 restart: $((RESTART_END - RESTART_START))s"
            echo "Health check: $((HEALTH_END - HEALTH_START))s"
            echo "TOTAL DEPLOYMENT TIME: ${TOTAL_TIME}s ($((TOTAL_TIME / 60))m $((TOTAL_TIME % 60))s)"
            echo "---END TIMING SUMMARY---"
          } > /tmp/deploy-timing.txt
          
          pm2 save
          echo "Deployment completed successfully at $(date)!"
          pm2 status
          DEPLOYEOF
          
          # Base64 encode the script to preserve all special characters
          SCRIPT_B64=$(base64 -w 0 < /tmp/deploy.sh)
          
          # Send command to EC2 via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --region us-east-1 \
            --parameters 'commands=["echo \"'"$SCRIPT_B64"'\" | base64 -d | bash"]' \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          
          # Don't wait - deployment runs asynchronously on EC2
          echo "✅ Deployment triggered successfully!"
          echo "Deployment is running in the background on EC2."
          echo "Check status: aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --region us-east-1"
          echo "Check timing: ssh to EC2 and run: cat /tmp/deploy-timing.txt"
