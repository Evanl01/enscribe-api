name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger from GitHub UI

env:
  NODE_VERSION: '22'
  NODE_ENV: 'production'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    name: Build & Test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint --if-present
        continue-on-error: true  # Don't fail deployment if lint fails

      - name: Run tests
        run: npm test
        continue-on-error: true  # Tests are informational

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    name: Deploy to EC2 via Systems Manager
    if: success()
    
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        env:
          AWS_ACTIONS_ACCESS_KEY_ID: ${{ secrets.AWS_ACTIONS_ACCESS_KEY_ID }}
          AWS_ACTIONS_SECRET_ACCESS_KEY: ${{ secrets.AWS_ACTIONS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AZURE_OPENAI_API_VERSION: ${{ secrets.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
          CLOUD_RUN_TRANSCRIBE_URL: ${{ secrets.CLOUD_RUN_TRANSCRIBE_URL }}
          CPU_THRESHOLD: ${{ secrets.CPU_THRESHOLD }}
          FASTIFY_PORT: ${{ secrets.FASTIFY_PORT }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          GCP_SERVICE_ACCOUNT_KEY: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          GCP_VM_INSTANCE_NAME: ${{ secrets.GCP_VM_INSTANCE_NAME }}
          GCP_VM_RATE_LIMIT_MAX_CALLS: ${{ secrets.GCP_VM_RATE_LIMIT_MAX_CALLS }}
          GCP_VM_RATE_LIMIT_WINDOW_SEC: ${{ secrets.GCP_VM_RATE_LIMIT_WINDOW_SEC }}
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_URL: ${{ secrets.GEMINI_API_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          REFRESH_COOKIE_DOMAIN: ${{ secrets.REFRESH_COOKIE_DOMAIN }}
          REFRESH_COOKIE_SAMESITE: ${{ secrets.REFRESH_COOKIE_SAMESITE }}
          REFRESH_COOKIE_SECURE: ${{ secrets.REFRESH_COOKIE_SECURE }}
          REFRESH_INACTIVITY_LIMIT_SECONDS: ${{ secrets.REFRESH_INACTIVITY_LIMIT_SECONDS }}
          REFRESH_MAX_AGE_SECONDS: ${{ secrets.REFRESH_MAX_AGE_SECONDS }}
          REFRESH_TOKEN_AES_KEY_HEX: ${{ secrets.REFRESH_TOKEN_AES_KEY_HEX }}
          REFRESH_TOKEN_SIGNING_KEY_HEX: ${{ secrets.REFRESH_TOKEN_SIGNING_KEY_HEX }}
          RSA_PRIVATE_KEY: ${{ secrets.RSA_PRIVATE_KEY }}
          RSA_PUBLIC_KEY: ${{ secrets.RSA_PUBLIC_KEY }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        run: |
          REQUIRED_SECRETS=(
            "AWS_ACTIONS_ACCESS_KEY_ID"
            "AWS_ACTIONS_SECRET_ACCESS_KEY"
            "AWS_REGION"
            "AZURE_OPENAI_API_VERSION"
            "AZURE_OPENAI_DEPLOYMENT"
            "AZURE_OPENAI_ENDPOINT"
            "AZURE_OPENAI_KEY"
            "CLOUD_RUN_TRANSCRIBE_URL"
            "CPU_THRESHOLD"
            "FASTIFY_PORT"
            "GCP_PROJECT_ID"
            "GCP_SERVICE_ACCOUNT_KEY"
            "GCP_VM_INSTANCE_NAME"
            "GCP_VM_RATE_LIMIT_MAX_CALLS"
            "GCP_VM_RATE_LIMIT_WINDOW_SEC"
            "GCP_ZONE"
            "GEMINI_API_KEY"
            "GEMINI_API_URL"
            "OPENAI_API_KEY"
            "OPENAI_API_URL"
            "REFRESH_COOKIE_SAMESITE"
            "REFRESH_COOKIE_SECURE"
            "REFRESH_INACTIVITY_LIMIT_SECONDS"
            "REFRESH_MAX_AGE_SECONDS"
            "REFRESH_TOKEN_AES_KEY_HEX"
            "REFRESH_TOKEN_SIGNING_KEY_HEX"
            "RSA_PRIVATE_KEY"
            "RSA_PUBLIC_KEY"
            "SUPABASE_ANON_KEY"
            "SUPABASE_SERVICE_ROLE_KEY"
            "SUPABASE_URL"
          )
          
          MISSING_SECRETS=()
          for SECRET in "${REQUIRED_SECRETS[@]}"; do
            if [ -z "${!SECRET}" ]; then
              MISSING_SECRETS+=("$SECRET")
            fi
          done
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "❌ Missing GitHub Secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "✅ All required secrets are configured"

      - name: Configure AWS Credentials via IAM User
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACTIONS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_ACTIONS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy via Systems Manager
        env:
          INSTANCE_ID: i-086b6a2ef671e8c63
        run: |
          # Create deployment script with all secrets
          cat > /tmp/deploy.sh << 'DEPLOYEOF'
          #!/bin/bash
          set -e
          
          # Set required environment variables for SSM
          export HOME=/home/ssm-user
          export USER=ssm-user
          
          # Load NVM for node/npm
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
          
          DEPLOY_START=$(date +%s)
          echo "Starting deployment at $(date)"
          cd /opt/enscribe-api
          
          PULL_START=$(date +%s)
          echo "Pulling latest code from main branch..."
          
          git config --global --add safe.directory /opt/enscribe-api
          git fetch origin main || { echo "Git fetch failed"; exit 1; }
          git reset --hard origin/main || { echo "Git reset failed"; exit 1; }
          
          PULL_END=$(date +%s)
          echo "✓ Git pull completed in $((PULL_END - PULL_START))s"
          echo "Current commit: $(git rev-parse --short HEAD)"
          
          INSTALL_START=$(date +%s)
          echo "Installing dependencies..."
          npm ci --omit=dev
          INSTALL_END=$(date +%s)
          echo "✓ npm install completed in $((INSTALL_END - INSTALL_START))s"
          
          ENV_START=$(date +%s)
          echo "Setting up environment variables..."
          cat > .env.local << 'ENVEOF'
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          FASTIFY_HOST=0.0.0.0
          FASTIFY_PORT=${{ secrets.FASTIFY_PORT }}
          NODE_ENV=production
          AZURE_OPENAI_API_VERSION=${{ secrets.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT=${{ secrets.AZURE_OPENAI_DEPLOYMENT }}
          AZURE_OPENAI_ENDPOINT=${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_KEY=${{ secrets.AZURE_OPENAI_KEY }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          OPENAI_API_URL=${{ secrets.OPENAI_API_URL }}
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_SERVICE_ACCOUNT_KEY=${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_API_URL=${{ secrets.GEMINI_API_URL }}
          GCP_ZONE=${{ secrets.GCP_ZONE }}
          GCP_VM_INSTANCE_NAME=${{ secrets.GCP_VM_INSTANCE_NAME }}
          GCP_VM_RATE_LIMIT_MAX_CALLS=${{ secrets.GCP_VM_RATE_LIMIT_MAX_CALLS }}
          GCP_VM_RATE_LIMIT_WINDOW_SEC=${{ secrets.GCP_VM_RATE_LIMIT_WINDOW_SEC }}
          CLOUD_RUN_TRANSCRIBE_URL=${{ secrets.CLOUD_RUN_TRANSCRIBE_URL }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          RSA_PRIVATE_KEY=${{ secrets.RSA_PRIVATE_KEY }}
          RSA_PUBLIC_KEY=${{ secrets.RSA_PUBLIC_KEY }}
          REFRESH_TOKEN_AES_KEY_HEX=${{ secrets.REFRESH_TOKEN_AES_KEY_HEX }}
          REFRESH_TOKEN_SIGNING_KEY_HEX=${{ secrets.REFRESH_TOKEN_SIGNING_KEY_HEX }}
          REFRESH_COOKIE_DOMAIN=${{ secrets.REFRESH_COOKIE_DOMAIN }}
          REFRESH_COOKIE_SAMESITE=${{ secrets.REFRESH_COOKIE_SAMESITE }}
          REFRESH_COOKIE_SECURE=${{ secrets.REFRESH_COOKIE_SECURE }}
          REFRESH_INACTIVITY_LIMIT_SECONDS=${{ secrets.REFRESH_INACTIVITY_LIMIT_SECONDS }}
          REFRESH_MAX_AGE_SECONDS=${{ secrets.REFRESH_MAX_AGE_SECONDS }}
          CPU_THRESHOLD=${{ secrets.CPU_THRESHOLD }}
          ENVEOF
          ENV_END=$(date +%s)
          echo "✓ Environment variables set in $((ENV_END - ENV_START))s"
          
          RESTART_START=$(date +%s)
          echo "Restarting Fastify backend..."
          # Kill any stuck processes on port 3001
          lsof -ti:3001 | xargs kill -9 2>/dev/null || true
          sleep 2
          
          # Restart or start PM2
          pm2 restart fastify-server 2>/dev/null || pm2 start npm --name "fastify-server" -- run start:fastify
          
          RESTART_END=$(date +%s)
          echo "✓ PM2 restart completed in $((RESTART_END - RESTART_START))s"
          
          HEALTH_START=$(date +%s)
          echo "Waiting for services to start..."
          sleep 5
          
          echo "Verifying backend health..."
          for i in {1..10}; do
            if curl -f -m 5 http://localhost:${{ secrets.FASTIFY_PORT }}/health > /dev/null 2>&1; then
              echo "✓ Fastify backend is healthy on port ${{ secrets.FASTIFY_PORT }}"
              break
            fi
            if [ $i -eq 10 ]; then
              echo "❌ Health check failed after 10 attempts"
              pm2 logs fastify-server --lines 20
              exit 1
            fi
            echo "Waiting for backend... ($i/10)"
            sleep 2
          done
          
          HEALTH_END=$(date +%s)
          echo "✓ Health check completed in $((HEALTH_END - HEALTH_START))s"
          
          DEPLOY_END=$(date +%s)
          TOTAL_TIME=$((DEPLOY_END - DEPLOY_START))
          
          echo "---DEPLOYMENT TIMING SUMMARY---"
          echo "Git pull: $((PULL_END - PULL_START))s"
          echo "npm install: $((INSTALL_END - INSTALL_START))s"
          echo "Environment setup: $((ENV_END - ENV_START))s"
          echo "PM2 restart: $((RESTART_END - RESTART_START))s"
          echo "Health check: $((HEALTH_END - HEALTH_START))s"
          echo "TOTAL DEPLOYMENT TIME: ${TOTAL_TIME}s"
          echo "---END TIMING SUMMARY---"
          
          # Write timing to file for retrieval
          {
            echo "---DEPLOYMENT TIMING SUMMARY---"
            echo "Git pull: $((PULL_END - PULL_START))s"
            echo "npm install: $((INSTALL_END - INSTALL_START))s"
            echo "Environment setup: $((ENV_END - ENV_START))s"
            echo "PM2 restart: $((RESTART_END - RESTART_START))s"
            echo "Health check: $((HEALTH_END - HEALTH_START))s"
            echo "TOTAL DEPLOYMENT TIME: ${TOTAL_TIME}s"
            echo "---END TIMING SUMMARY---"
          } > /tmp/deploy-timing.txt
          
          pm2 save
          echo "✅ Deployment completed successfully at $(date)!"
          pm2 status
          DEPLOYEOF
          
          # Base64 encode the script to preserve all special characters
          SCRIPT_B64=$(base64 -w 0 < /tmp/deploy.sh)
          
          # Send command to EC2 via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --region us-east-1 \
            --parameters 'commands=["echo \"'"$SCRIPT_B64"'\" | base64 -d | bash"]' \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Command ID: $COMMAND_ID"
          echo "⏳ Waiting for deployment to complete..."
          
          # Poll for command completion (max 5 minutes)
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region us-east-1 \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS - Status: $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment completed successfully!"
              
              # Show deployment output
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region us-east-1 \
                --query 'StandardOutputContent' \
                --output text
              
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "❌ Deployment failed!"
              
              # Show error output
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region us-east-1 \
                --query 'StandardOutputContent' \
                --output text
              
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region us-east-1 \
                --query 'StandardErrorContent' \
                --output text
              
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            sleep 5
          done
          
          echo "⚠️ Deployment timed out after 5 minutes"
          echo "Check manually: aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --region us-east-1"
          exit 1